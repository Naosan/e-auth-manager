# eBay OAuth Token 管理の現状と方針（共有メモ）

このメモは、本ワークスペースにおける eBay OAuth トークン管理の現状確認結果と、運用上の注意点・おすすめ方針をまとめたものです。

## 目的
- どこでトークンが保存・参照されるかを明確化
- 「DBに値がなくても OS 既定ディレクトリの暗号化JSONから復元して動かす」要件の可否と運用案を提示

## 管理の主体（ライブラリ）
- 使用ライブラリ: `@naosan/e-auth-manager`（本リポジトリにインストール済）
  - デフォルトで「データベース（主）＋暗号化JSON（従）」のデュアルストレージ
  - アクセストークン取得の優先順: メモリ → 暗号化JSON → DB →（失効時）eBayで更新

## 保存先の既定
- データベース（主）
  - 既定: `./database/ebay_tokens.sqlite`
  - `.env`で `EBAY_DATABASE_PATH` を指定可能
- 暗号化JSON（従／キャッシュ・バックアップ）
  - Windows 既定: `C:\\Users\\<ユーザー>\\AppData\\Local\\ebay-oauth-tokens\\ebay-tokens.encrypted.json`
  - 互換レガシー（存在すれば優先）: `C:\\ProgramData\\ebay-oauth-tokens\\...` / `C:\\Users\\<ユーザー>\\AppData\\Local\\EStocks\\tokens\\...`
  - `.env`で `EBAY_TOKEN_FILE_PATH` を指定可能
- 共有JSON（SSOT・オプション）
  - `.env` の `OAUTH_SSOT_JSON` を指定すると、更新時の refresh_token をここから取得・更新可能（マシン非依存暗号化）

## 現状確認（抜粋）
- トークンDBの実体は `database/ebay_tokens.sqlite`。
  - `scripts/inspect-ebay-tokens.js` で `ebay_oauth_tokens` テーブルに1件のレコードを確認（更新日時あり）
- `database/ebay_api_listing.sqlite` には `ebay_oauth_tokens` テーブルは存在しない（混同注意）
- `checkRefreshTokenValidity(appId)` の実行結果は `true`（現行環境では refresh_token 有効）
- Windowsの暗号化JSONは、未作成（「保存イベント」が未発生の場合はファイルがないのが正常）
- `.env` の鍵系はライブラリ的には `EBAY_OAUTH_TOKEN_MANAGER_MASTER_KEY` を使用（`EBAY_MASTER_KEY` は混乱源になりやすい）

## 仕様・挙動の要点
- 暗号化JSONは「アクセストークン利用の高速キャッシュ」兼「バックアップ」。作成は初回保存・更新時に行われる。
  - DBへ手動投入のみだと、JSONは未生成のまま残りうる
- `checkRefreshTokenValidity()` はDBベースの確認で、JSONのみの運用にはフォールバックしない設計
- 失効時の更新は、原則DB（またはSSOT）にある refresh_token を起点に実施
- 暗号鍵の指紋管理（`oauth_metadata.encryption_fingerprint`）
  - マスターキーやマシンIDが変わると指紋不一致で既存トークンをパージ（安全側の仕様）
- OS間共有（Windows↔Linux）
  - ローカル暗号化JSONはマシンID依存鍵のため復号不可になりがち。マシン間共有はSSOT利用が安全

## 想定ユースケースとおすすめ方針
1) DB中心（最小変更・安定）
   - 初回だけDBへ1レコードをシード（以後、保存イベントで暗号化JSONも自動生成・更新）
   - すべてのアプリで同一の `EBAY_DATABASE_PATH` を参照して共有

2) DBゼロでも起動可能にしたい（JSON or SSOT→DB復元）
   - SSOT（`.env: OAUTH_SSOT_JSON`）を有効化し、起動時にDB未存在なら SSOT から refresh_token を読み込んで `setRefreshToken(...)` でDBへ自動シード
   - 或いはローカル暗号化JSONから復元→DBへ同期するブートストラップをアプリ起動時に一度だけ実行

3) チェックゲートの見直し（可用性優先）
   - `checkRefreshTokenValidity()` ではなく、`getTradingApiToken(appId)` の実取得成功/失敗で通過判定
   - DBが空でもJSONに未失効アクセストークンがあれば通せる（ただし失効後は2)の仕組みが必要）

## よくある躓きポイント
- 「DBに直接入れたのにJSONがない」
  - JSONは保存イベント時に生成されるため、初回は `setRefreshToken(...)` または強制更新で保存イベントを発生させる
- 「DBが空だと checkRefreshTokenValidity が失敗する」
  - 設計上DB前提。ゲートを `getTradingApiToken(appId)` に切り替えるか、起動時復元（JSON/SSOT→DB）を入れる
- 「OS間でJSONを使い回したい」
  - ローカルJSONはマシンID依存。SSOTを使う

## 次のアクション（選択）
- A) 現行維持: `database/ebay_tokens.sqlite` に初回シードを保証し、以降は自動デュアル保存
- B) SSOT導入: `.env` に `OAUTH_SSOT_JSON` と `EBAY_OAUTH_TOKEN_MANAGER_MASTER_KEY` を設定し、起動時にDB未存在ならSSOT→DBへ自動シード
- C) 起動ブートストラップ: ローカル暗号化JSON→DBへの同期ユーティリティを起動直後に一度呼ぶ
- 併せて、ゲートは `getTradingApiToken(appId)` ベースへ（可用性◎）

## 便利コマンド（確認用）
- DBのトークン確認: `node scripts/inspect-ebay-tokens.js database/ebay_tokens.sqlite`
- 既定の暗号化JSON保存先を表示（Windows）
  - `node -e "import('dotenv/config'); import('@naosan/e-auth-manager/file').then(({default:M})=>console.log(new M({ masterKey: process.env.EBAY_OAUTH_TOKEN_MANAGER_MASTER_KEY }).tokenFile))"`

## 備考
- トークンや鍵の値（clientId/clientSecret/masterKey）はログ・ドキュメントへ直接記載しないこと
- SQLiteファイル共有は同一マシン内が推奨。マシン間共有が必要な場合はSSOTを使用
